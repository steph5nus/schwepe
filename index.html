<!-- Schwepe.co.za -->
<!-- weareonethreethreesevenheclgang @ 247420 -->
<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Hi I'm Schwepe</title>
	<link rel="icon" type="image/x-icon" href="https://cdn.discordapp.com/emojis/893594073250807828.webp">
	<meta property="og:title" content="schwepe" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="https://schwepe.co.za" />
	<meta property="og:image" content="https://cdn.discordapp.com/emojis/893594073250807828.webp" />
	<meta property="og:description" content="the official website for schwepe. an entrypoint probably emerging." />
	<meta name="theme-color" content="#e094e6">
	<!-- Include this to make the og:image larger -->
	<meta name="twitter:card" content="summary_large_image">
	<style>
		body,
		html {
			margin: 0;
			padding: 0;
			background: #25252B;
		}

		* {
			touch-action: manipulation;
		}

		*,
		*:before,
		*:after {
			box-sizing: border-box;
		}

		body {
			position: relative;
			color: white;
			letter-spacing: 2px;
			font-size: 11px;
			font-family: 'Poppins', sans-serif;
			width: 100%;
			height: 100vh;
			background-color: #d699ff;
			background-image: radial-gradient(at 66% 13%, hsla(263, 84%, 68%, 1) 0px, transparent 50%),
				radial-gradient(at 65% 60%, hsla(230, 67%, 76%, 1) 0px, transparent 50%),
				radial-gradient(at 33% 9%, hsla(251, 85%, 70%, 1) 0px, transparent 50%),
				radial-gradient(at 79% 11%, hsla(348, 62%, 79%, 1) 0px, transparent 50%),
				radial-gradient(at 52% 8%, hsla(288, 70%, 68%, 1) 0px, transparent 50%),
				radial-gradient(at 4% 22%, hsla(152, 76%, 67%, 1) 0px, transparent 50%),
				radial-gradient(at 22% 78%, hsla(315, 68%, 74%, 1) 0px, transparent 50%);
		}

		.wrapper {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
		}

		p {
			max-width: 600px;
			margin-left: auto;
			margin-right: auto;
			padding: 0 2em;
		}

		.info {
			position: absolute;
			display: block;
			cursor: pointer;
			top: 0px;
			width: 100%;
			padding: 10px;
			box-sizing: border-box;
			text-align: center;
			z-index: 1;
			/* TODO Solve this in HTML */
		}

		#c {
			position: absolute;
			top: 0;
			background-color: #99fff1;
			background-image:
				radial-gradient(at 36% 21%, hsla(13, 97%, 63%, 1) 0px, transparent 50%),
				radial-gradient(at 92% 93%, hsla(344, 74%, 73%, 1) 0px, transparent 50%),
				radial-gradient(at 37% 57%, #e094e6 0px, transparent 50%),
				radial-gradient(at 91% 89%, hsla(235, 94%, 77%, 1) 0px, transparent 50%),
				radial-gradient(at 18% 29%, hsla(42, 65%, 66%, 1) 0px, transparent 50%),
				radial-gradient(at 33% 63%, hsla(124, 96%, 74%, 1) 0px, transparent 50%),
				radial-gradient(at 61% 11%, hsla(75, 83%, 64%, 1) 0px, transparent 50%);
			width: 100%;
			height: 100%;
			display: block;
		}

		.loading {
			position: fixed;
			z-index: 50;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			background-color: #99fff1;
			background-image:
				radial-gradient(at 36% 21%, hsla(13, 97%, 63%, 1) 0px, transparent 50%),
				radial-gradient(at 92% 93%, hsla(344, 74%, 73%, 1) 0px, transparent 50%),
				radial-gradient(at 37% 57%, hsla(296, 62%, 74%, 1) 0px, transparent 50%),
				radial-gradient(at 91% 89%, hsla(235, 94%, 77%, 1) 0px, transparent 50%),
				radial-gradient(at 18% 29%, hsla(42, 65%, 66%, 1) 0px, transparent 50%),
				radial-gradient(at 33% 63%, hsla(124, 96%, 74%, 1) 0px, transparent 50%),
				radial-gradient(at 61% 11%, hsla(75, 83%, 64%, 1) 0px, transparent 50%);
			display: flex;
			justify-content: center;
			align-items: center;
		}

		.loader {
			-webkit-perspective: 120px;
			-moz-perspective: 120px;
			-ms-perspective: 120px;
			perspective: 120px;
			width: 100px;
			height: 100px;
		}

		.loader:before {
			content: "";
			position: absolute;
			left: 25px;
			top: 25px;
			width: 50px;
			height: 50px;
			background-color: #9bffaf;
			animation: flip 1s infinite;
		}

		@keyframes flip {
			0% {
				transform: rotate(0);
			}

			50% {
				transform: rotateY(180deg);
			}

			100% {
				transform: rotateY(180deg) rotateX(180deg);
			}
		}

		.top-text {
			position: absolute;
			display: block;
			z-index: 100;
			bottom: 2em;
			left: 2em;
			font-weight: bold;
		}
	</style>
	<!-- <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script> -->
	<!-- <script src="https://unpkg.com/aframe-gradient-sky@1.3.0/dist/gradientsky.min.js"></script> -->
</head>

<body>
	<p>
	<img src="https://media.discordapp.net/attachments/843928612276273162/1058477366407614654/image.png?width=894&height=497" alt="A schwepe meme" width="200" height="100" class="my-image">
	</p>
	<!-- The loading element overlays all else until the model is loaded, at which point we remove this element from the DOM -->
	<div class="loading" id="js-loader">
		<div class="loader"></div>
	</div>
	<div class="info">
		a <a href="https://woodmurderedhat.com" target="_blank" rel="noopener">wood🪵murdered🪓hat👒</a> idea,<br />
		formed in <a href="https://dsc.gg/entrypoint" target="_blank" rel="noopener">an entrypoint</a>,<br />
		modeled by <a href="https://irb0gie.vercel.app/" target="_blank" rel="noopener">👒szab0️⃣genie🧞</a>
	</div>
	<div class="wrapper">
		<!-- The canvas element is used to draw the 3D scene -->
		<canvas id="c"></canvas>
	</div>
	<figcaption class="top-text" style="color: hsl(218, 81%, 75%)">
		Ａｎ🎙️Ｅｎｔｒｙｐ❍ｉｎｔ， <br />
		<a target="_blank" href="https://dsc.gg/entrypoint">
			<cite title="Source Title">ｐｒ❍ｂａｂｌｙ　ｅｎｔｅｒｉｎｇ❓</cite>
		</a>
		<a rel="me" href="https://mastodon.247420.xyz/@schwepe">🐘</a>
	</figcaption>
	<script src="js/KeybaordState.js"></script>
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
	    "imports": {
	      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.module.js"
	    }
	  }
						</script>
	<script type="module">

		import * as THREE from 'three';
		import Stats from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/libs/stats.module.js';
		import { GUI } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/libs/lil-gui.module.min.js';
		import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/controls/OrbitControls.js';
		import { CinematicCamera } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/cameras/CinematicCamera.js';
		(function () {

			// Set our main variables
			let container,
				scene,
				stats, gui,
				clock = new THREE.Clock(),
				renderer, camera,
				model, neck, waist, face,
				mixer, idle, blink, jump,
				raycaster = new THREE.Raycaster(),

				keyboard = new KeyboardState(),
				loaderAnim = document.getElementById('js-loader');

			init();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new CinematicCamera(20, window.innerWidth / window.innerHeight, 0.1, 1000);
				camera.position.set(0, -2.9, 45);

				const canvas = document.querySelector('#c');
				const GLB_PATH = 'schwepev2.glb';

				// scene 
				const backgroundColor = 0xe0e0e0;
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(backgroundColor, 60, 1000);

				// lights
				const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.61);
				hemiLight.position.set(0, 50, 0);
				// Add hemisphere light to scene
				scene.add(hemiLight);

				let d = 8.25;
				let dirLight = new THREE.DirectionalLight(0xffffff, 0.54);
				dirLight.position.set(-8, 12, 8);
				dirLight.castShadow = true;
				dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 1500;
				dirLight.shadow.camera.left = d * -1;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = d * -1;
				// Add directional Light to scene
				scene.add(dirLight);

				// ground
				const floorTexture = new THREE.TextureLoader().load("./images/checkerboard.jpg");
				floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
				floorTexture.repeat.set(10, 10);
				let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 1, 1);
				let floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture });

				let floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.rotation.x = -0.5 * Math.PI; // This is 90 degrees by the way
				floor.receiveShadow = true;
				floor.position.y = -11;
				scene.add(floor);

				//cute green cube
				const cube = new THREE.Mesh(
					new THREE.BoxGeometry(1, 1, 1),
					new THREE.MeshBasicMaterial({ color: 0x00ff00 })
				);

				cube.position.z = 15;
				cube.position.y = -5;

				scene.add(cube); //this IS clickable

				// the holy juan
				const loader = new GLTFLoader();
				loader.load(GLB_PATH, function (gltf) {

					const schwepe = gltf.scene;
					let schwepeAnims = gltf.animations;
					schwepe.scale.set(4, 4, 4);
					schwepe.position.y = -11;
					scene.add(schwepe);

					schwepe.traverse(o => {
						if (o.isMesh) {
							o.receiveShadow = true;
						}
						if (o.isBone && o.name === 'mixamorigNeck') {
							neck = o;
						}
						if (o.isBone && o.name === 'mixamorigSpine') {
							waist = o;
						}
					});

					loaderAnim.remove();

					mixer = new THREE.AnimationMixer(schwepe);

					let blinkAnim = THREE.AnimationClip.findByName(schwepeAnims, 'blink');
					blinkAnim.tracks.splice(3, 3);
					blinkAnim.tracks.splice(9, 3);
					mixer.clipAction(blinkAnim).play();

					let idleAnim = THREE.AnimationClip.findByName(schwepeAnims, 'idle');
					idleAnim.tracks.splice(3, 3);
					idleAnim.tracks.splice(9, 3);
					mixer.clipAction(idleAnim).play();


					let jumpAnim = THREE.AnimationClip.findByName(schwepeAnims, 'jump');
					jumpAnim.tracks.splice(3, 3);
					jumpAnim.tracks.splice(9, 3);

					keyboard.update();

					update();
				}, undefined, function (error) { console.error(error); });

				// renderer
				renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.setPixelRatio(window.devicePixelRatio);
				document.body.appendChild(renderer.domElement);

				// stats
				stats = new Stats();
				container.appendChild(stats.dom);

				const controls = new OrbitControls(camera, renderer.domElement);

				function update() {
					const dt = clock.getDelta();
					if (mixer) mixer.update(dt);
					requestAnimationFrame(update);
					keyboard.update();
					cube.rotation.x += .004;
					cube.rotation.y += .004;
					cube.rotation.z += .004;
					if (resizeRendererToDisplaySize(renderer)) {
						const canvas = renderer.domElement;
						camera.aspect = canvas.clientWidth / canvas.clientHeight;
						camera.updateProjectionMatrix();
					}
					stats.update();
					renderer.render(scene, camera);
				}

				update();

				function resizeRendererToDisplaySize(renderer) {
					const canvas = renderer.domElement;
					let width = window.innerWidth;
					let height = window.innerHeight;
					let canvasPixelWidth = canvas.width / window.devicePixelRatio;
					let canvasPixelHeight = canvas.height / window.devicePixelRatio;
					const needResize =
						canvasPixelWidth !== width || canvasPixelHeight !== height;
					if (needResize) {
						renderer.setSize(width, height, false);
					}
					return needResize;
				}
				window.addEventListener('click', e => raycast(e));
				window.addEventListener('touchend', e => raycast(e, true));
				function raycast(e, touch = false) {
					var mouse = {};
					if (touch) {
						mouse.x = 2 * (e.changedTouches[0].clientX / window.innerWidth) - 1;
						mouse.y = 1 - 2 * (e.changedTouches[0].clientY / window.innerHeight);
					} else {
						mouse.x = 2 * (e.clientX / window.innerWidth) - 1;
						mouse.y = 1 - 2 * (e.clientY / window.innerHeight);
					}
					// update the picking ray with the camera and mouse position
					raycaster.setFromCamera(mouse, camera);
					// calculate objects intersecting the picking ray
					let intersects = raycaster.intersectObjects(scene.children);
					for (let i = 0; i < intersects.length; i++) {
						if (intersects[i].object.id === 14) {
							console.log("i\'m not simply a weird floating green cube");
							startOriginStory();
						}
					}

				}
				function startOriginStory() {
					alert("looks liketh thee wanteth to learneth m\'re about me.  doth not w\'rry.  all answ\'rs shall maketh themselves presenteth quite sh\'rtly.  remaineth halcyon, diligent and most imp\'rtantly patient! click 🆗 when you are ready.");
					window.location.href = "https://about.247420.xyz";
				}

				function playModifierAnimation(from, fSpeed, to, tSpeed) {
					to.setLoop(THREE.LoopOnce);keyyba
					to.reset();
					to.play();
					from.crossFadeTo(to, fSpeed, true);
					setTimeout(function () {
						from.enabled = true;
						to.crossFadeTo(from, tSpeed, true);
						currentlyAnimating = false;
					}, to._clip.duration * 1000 - ((tSpeed + fSpeed) * 1000));
				}

				document.addEventListener('mousemove', function (e) {

					var mousecoords = getMousePos(e);

					if (neck && waist) {
						moveJoint(mousecoords, neck, 50);
						moveJoint(mousecoords, waist, 30);
					}

				});

				function getMousePos(e) {
					return {
						x: e.clientX,
						y: e.clientY
					};
				}

				function moveJoint(mouse, joint, degreeLimit) {
					let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
					joint.rotation.y = THREE.Math.degToRad(degrees.x);
					joint.rotation.x = THREE.Math.degToRad(degrees.y);
				}

				function getMouseDegrees(x, y, degreeLimit) {

					let dx = 0,
						dy = 0,
						xdiff,
						xPercentage,
						ydiff,
						yPercentage;

					let w = { x: window.innerWidth, y: window.innerHeight };

					// Left (Rotates neck left between 0 and -degreeLimit)

					// 1. If cursor is in the left half of screen
					if (x <= w.x / 2) {
						// 2. Get the difference between middle of screen and cursor position
						xdiff = w.x / 2 - x;
						// 3. Find the percentage of that difference (percentage toward edge of screen)
						xPercentage = (xdiff / (w.x / 2)) * 100;
						// 4. Convert that to a percentage of the maximum rotation we allow for the neck
						dx = ((degreeLimit * xPercentage) / 100) * -1;
					}
					// Right (Rotates neck right between 0 and degreeLimit)
					if (x >= w.x / 2) {
						xdiff = x - w.x / 2;
						xPercentage = (xdiff / (w.x / 2)) * 100;
						dx = (degreeLimit * xPercentage) / 100;
					}
					// Up (Rotates neck up between 0 and -degreeLimit)
					if (y <= w.y / 2) {
						ydiff = w.y / 2 - y;
						yPercentage = (ydiff / (w.y / 2)) * 100;
						// Note that I cut degreeLimit in half when she looks up
						dy = (((degreeLimit * 0.5) * yPercentage) / 100) * -1;
					}
					// Down (Rotates neck down between 0 and degreeLimit)
					if (y >= w.y / 2) {
						ydiff = y - w.y / 2;
						yPercentage = (ydiff / (w.y / 2)) * 100;
						dy = (degreeLimit * yPercentage) / 100;
					}
					return { x: dx, y: dy };

				}

			}

		})(); //endpoint
	</script>
</body>

</html>
