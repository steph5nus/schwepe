<!-- Schwepe.co.za -->
<!-- weareonethreethreesevenheclgang @ 247420 -->
<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Hi I'm Schwepe</title>
	<link rel="icon" type="image/x-icon" href="https://cdn.discordapp.com/emojis/893594073250807828.webp">
	<meta property="og:title" content="schwepe" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="https://schwepe.co.za" />
	<meta property="og:image" content="https://cdn.discordapp.com/emojis/893594073250807828.webp" />
	<meta property="og:description" content="the official website for schwepe. an entrypoint probably emerging." />
	<meta name="theme-color" content="#e094e6">
	<!-- Include this to make the og:image larger -->
	<meta name="twitter:card" content="summary_large_image">
	<style>
		body,
		html {
			margin: 0;
			padding: 0;
			background: #25252B;
		}

		* {
			touch-action: manipulation;
		}

		*,
		*:before,
		*:after {
			box-sizing: border-box;
		}

		body {
			position: relative;
			color: white;
			letter-spacing: 2px;
			font-size: 11px;
			font-family: 'Poppins', sans-serif;
			width: 100%;
			height: 100vh;
			background-color: #d699ff;
			background-image: radial-gradient(at 66% 13%, hsla(263, 84%, 68%, 1) 0px, transparent 50%),
				radial-gradient(at 65% 60%, hsla(230, 67%, 76%, 1) 0px, transparent 50%),
				radial-gradient(at 33% 9%, hsla(251, 85%, 70%, 1) 0px, transparent 50%),
				radial-gradient(at 79% 11%, hsla(348, 62%, 79%, 1) 0px, transparent 50%),
				radial-gradient(at 52% 8%, hsla(288, 70%, 68%, 1) 0px, transparent 50%),
				radial-gradient(at 4% 22%, hsla(152, 76%, 67%, 1) 0px, transparent 50%),
				radial-gradient(at 22% 78%, hsla(315, 68%, 74%, 1) 0px, transparent 50%);
		}

		.wrapper {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
		}

		p {
			max-width: 600px;
			margin-left: auto;
			margin-right: auto;
			padding: 0 2em;
		}

		.info {
			position: absolute;
			display: block;
			cursor: pointer;
			top: 0px;
			width: 100%;
			padding: 10px;
			box-sizing: border-box;
			text-align: center;
			z-index: 1;
			/* TODO Solve this in HTML */
		}

		#c {
			position: absolute;
			top: 0;
			background-color: #99fff1;
			background-image:
				radial-gradient(at 36% 21%, hsla(13, 97%, 63%, 1) 0px, transparent 50%),
				radial-gradient(at 92% 93%, hsla(344, 74%, 73%, 1) 0px, transparent 50%),
				radial-gradient(at 37% 57%, #e094e6 0px, transparent 50%),
				radial-gradient(at 91% 89%, hsla(235, 94%, 77%, 1) 0px, transparent 50%),
				radial-gradient(at 18% 29%, hsla(42, 65%, 66%, 1) 0px, transparent 50%),
				radial-gradient(at 33% 63%, hsla(124, 96%, 74%, 1) 0px, transparent 50%),
				radial-gradient(at 61% 11%, hsla(75, 83%, 64%, 1) 0px, transparent 50%);
			width: 100%;
			height: 100%;
			display: block;
		}

		.loading {
			position: fixed;
			z-index: 50;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			background-color: #99fff1;
			background-image:
				radial-gradient(at 36% 21%, hsla(13, 97%, 63%, 1) 0px, transparent 50%),
				radial-gradient(at 92% 93%, hsla(344, 74%, 73%, 1) 0px, transparent 50%),
				radial-gradient(at 37% 57%, hsla(296, 62%, 74%, 1) 0px, transparent 50%),
				radial-gradient(at 91% 89%, hsla(235, 94%, 77%, 1) 0px, transparent 50%),
				radial-gradient(at 18% 29%, hsla(42, 65%, 66%, 1) 0px, transparent 50%),
				radial-gradient(at 33% 63%, hsla(124, 96%, 74%, 1) 0px, transparent 50%),
				radial-gradient(at 61% 11%, hsla(75, 83%, 64%, 1) 0px, transparent 50%);
			display: flex;
			justify-content: center;
			align-items: center;
		}

		.loader {
			-webkit-perspective: 120px;
			-moz-perspective: 120px;
			-ms-perspective: 120px;
			perspective: 120px;
			width: 100px;
			height: 100px;
		}

		.loader:before {
			content: "";
			position: absolute;
			left: 25px;
			top: 25px;
			width: 50px;
			height: 50px;
			background-color: #9bffaf;
			animation: flip 1s infinite;
		}

		@keyframes flip {
			0% {
				transform: rotate(0);
			}

			50% {
				transform: rotateY(180deg);
			}

			100% {
				transform: rotateY(180deg) rotateX(180deg);
			}
		}

		.top-text {
			position: absolute;
			display: block;
			z-index: 100;
			bottom: 2em;
			left: 2em;
			font-weight: bold;
		}
	</style>
	<!-- <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script> -->
	<!-- <script src="https://unpkg.com/aframe-gradient-sky@1.3.0/dist/gradientsky.min.js"></script> -->
</head>

<body>
	<p>
	<img src="https://media.discordapp.net/attachments/843928612276273162/1058477366407614654/image.png?width=894&height=497" alt="A schwepe meme" width="200" height="100" class="my-image">
	</p>
	<!-- The loading element overlays all else until the model is loaded, at which point we remove this element from the DOM -->
	<div class="loading" id="js-loader">
		<div class="loader"></div>
	</div>
	<div class="info">
		a <a href="https://woodmurderedhat.com" target="_blank" rel="noopener">woodğŸªµmurderedğŸª“hatğŸ‘’</a> idea,<br />
		formed in <a href="https://dsc.gg/entrypoint" target="_blank" rel="noopener">an entrypoint</a>,<br />
		modeled by <a href="https://irb0gie.vercel.app/" target="_blank" rel="noopener">ğŸ‘’szab0ï¸âƒ£genieğŸ§</a>
	</div>
	<div class="wrapper">
		<!-- The canvas element is used to draw the 3D scene -->
		<canvas id="c"></canvas>
	</div>
	<figcaption class="top-text" style="color: hsl(218, 81%, 75%)">
		ï¼¡ï½ğŸ™ï¸ï¼¥ï½ï½”ï½’ï½™ï½âï½‰ï½ï½”ï¼Œ <br />
		<a target="_blank" href="https://dsc.gg/entrypoint">
			<cite title="Source Title">ï½ï½’âï½‚ï½ï½‚ï½Œï½™ã€€ï½…ï½ï½”ï½…ï½’ï½‰ï½ï½‡â“</cite>
		</a>
		<a rel="me" href="https://mastodon.247420.xyz/@schwepe">ğŸ˜</a>
	</figcaption>
	<script src="js/KeybaordState.js"></script>
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
	    "imports": {
	      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.module.js"
	    }
	  }
						</script>
	<script type="module">

		import * as THREE from 'three';
		import Stats from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/libs/stats.module.js';
		import { GUI } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/libs/lil-gui.module.min.js';
		import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/controls/OrbitControls.js';
		import { CinematicCamera } from 'https://cdn.jsdelivr.net/npm/three@0.142.0/examples/jsm/cameras/CinematicCamera.js';
		(function () {

			// Set our main variables
			let container,
				scene,
				stats, gui,
				clock = new THREE.Clock(),
				renderer, camera,
				model, neck, waist, face,
				mixer, idle, blink, jump,
				raycaster = new THREE.Raycaster(),

				keyboard = new KeyboardState(),
				loaderAnim = document.getElementById('js-loader');

			init();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new CinematicCamera(20, window.innerWidth / window.innerHeight, 0.1, 1000);
				camera.position.set(0, -2.9, 45);

				const canvas = document.querySelector('#c');
				const GLB_PATH = 'schwepev2.glb';

				// scene 
				const backgroundColor = 0xe0e0e0;
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(backgroundColor, 60, 1000);

				// lights
				const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.61);
				hemiLight.position.set(0, 50, 0);
				// Add hemisphere light to scene
				scene.add(hemiLight);

				let d = 8.25;
				let dirLight = new THREE.DirectionalLight(0xffffff, 0.54);
				dirLight.position.set(-8, 12, 8);
				dirLight.castShadow = true;
				dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 1500;
				dirLight.shadow.camera.left = d * -1;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = d * -1;
				// Add directional Light to scene
				scene.add(dirLight);

				// ground
				const floorTexture = new THREE.TextureLoader().load("./images/checkerboard.jpg");
				floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
				floorTexture.repeat.set(10, 10);
				let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 1, 1);
				let floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture });

				let floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.rotation.x = -0.5 * Math.PI; // This is 90 degrees by the way
				floor.receiveShadow = true;
				floor.position.y = -11;
				scene.add(floor);

				//cute green cube
				const cube = new THREE.Mesh(
					new THREE.BoxGeometry(1, 1, 1),
					new THREE.MeshBasicMaterial({ color: 0x00ff00 })
				);

				cube.position.z = 15;
				cube.position.y = -5;

				scene.add(cube); //this IS clickable

				// the holy juan
				const loader = new GLTFLoader();
				loader.load(GLB_PATH, function (gltf) {

					const schwepe = gltf.scene;
					let schwepeAnims = gltf.animations;
					schwepe.scale.set(4, 4, 4);
					schwepe.position.y = -11;
					scene.add(schwepe);

					schwepe.traverse(o => {
						if (o.isMesh) {
							o.receiveShadow = true;
						}
						if (o.isBone && o.name === 'mixamorigNeck') {
							neck = o;
						}
						if (o.isBone && o.name === 'mixamorigSpine') {
							waist = o;
						}
					});

					loaderAnim.remove();

					mixer = new THREE.AnimationMixer(schwepe);

					let blinkAnim = THREE.AnimationClip.findByName(schwepeAnims, 'blink');
					blinkAnim.tracks.splice(3, 3);
					blinkAnim.tracks.splice(9, 3);
					mixer.clipAction(blinkAnim).play();

					let idleAnim = THREE.AnimationClip.findByName(schwepeAnims, 'idle');
					idleAnim.tracks.splice(3, 3);
					idleAnim.tracks.splice(9, 3);
					mixer.clipAction(idleAnim).play();


					let jumpAnim = THREE.AnimationClip.findByName(schwepeAnims, 'jump');
					jumpAnim.tracks.splice(3, 3);
					jumpAnim.tracks.splice(9, 3);

					keyboard.update();

					update();
				}, undefined, function (error) { console.error(error); });

				// renderer
				renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.setPixelRatio(window.devicePixelRatio);
				document.body.appendChild(renderer.domElement);

				// stats
				stats = new Stats();
				container.appendChild(stats.dom);

				const controls = new OrbitControls(camera, renderer.domElement);

				function update() {
					const dt = clock.getDelta();
					if (mixer) mixer.update(dt);
					requestAnimationFrame(update);
					keyboard.update();
					cube.rotation.x += .004;
					cube.rotation.y += .004;
					cube.rotation.z += .004;
					if (resizeRendererToDisplaySize(renderer)) {
						const canvas = renderer.domElement;
						camera.aspect = canvas.clientWidth / canvas.clientHeight;
						camera.updateProjectionMatrix();
					}
					stats.update();
					renderer.render(scene, camera);
				}

				update();

				function resizeRendererToDisplaySize(renderer) {
					const canvas = renderer.domElement;
					let width = window.innerWidth;
					let height = window.innerHeight;
					let canvasPixelWidth = canvas.width / window.devicePixelRatio;
					let canvasPixelHeight = canvas.height / window.devicePixelRatio;
					const needResize =
						canvasPixelWidth !== width || canvasPixelHeight !== height;
					if (needResize) {
						renderer.setSize(width, height, false);
					}
					return needResize;
				}
				window.addEventListener('click', e => raycast(e));
				window.addEventListener('touchend', e => raycast(e, true));
				function raycast(e, touch = false) {
					var mouse = {};
					if (touch) {
						mouse.x = 2 * (e.changedTouches[0].clientX / window.innerWidth) - 1;
						mouse.y = 1 - 2 * (e.changedTouches[0].clientY / window.innerHeight);
					} else {
						mouse.x = 2 * (e.clientX / window.innerWidth) - 1;
						mouse.y = 1 - 2 * (e.clientY / window.innerHeight);
					}
					// update the picking ray with the camera and mouse position
					raycaster.setFromCamera(mouse, camera);
					// calculate objects intersecting the picking ray
					let intersects = raycaster.intersectObjects(scene.children);
					for (let i = 0; i < intersects.length; i++) {
						if (intersects[i].object.id === 14) {
							console.log("i\'m not simply a weird floating green cube");
							startOriginStory();
						}
					}

				}
				function startOriginStory() {
					alert("looks liketh thee wanteth to learneth m\'re about me.  doth not w\'rry.  all answ\'rs shall maketh themselves presenteth quite sh\'rtly.  remaineth halcyon, diligent and most imp\'rtantly patient! click ğŸ†— when you are ready.");
					window.location.href = "https://about.247420.xyz";
				}

				function playModifierAnimation(from, fSpeed, to, tSpeed) {
					to.setLoop(THREE.LoopOnce);keyyba
					to.reset();
					to.play();
					from.crossFadeTo(to, fSpeed, true);
					setTimeout(function () {
						from.enabled = true;
						to.crossFadeTo(from, tSpeed, true);
						currentlyAnimating = false;
					}, to._clip.duration * 1000 - ((tSpeed + fSpeed) * 1000));
				}

				document.addEventListener('mousemove', function (e) {

					var mousecoords = getMousePos(e);

					if (neck && waist) {
						moveJoint(mousecoords, neck, 50);
						moveJoint(mousecoords, waist, 30);
					}

				});

				function getMousePos(e) {
					return {
						x: e.clientX,
						y: e.clientY
					};
				}

				function moveJoint(mouse, joint, degreeLimit) {
					let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
					joint.rotation.y = THREE.Math.degToRad(degrees.x);
					joint.rotation.x = THREE.Math.degToRad(degrees.y);
				}

				function getMouseDegrees(x, y, degreeLimit) {

					let dx = 0,
						dy = 0,
						xdiff,
						xPercentage,
						ydiff,
						yPercentage;

					let w = { x: window.innerWidth, y: window.innerHeight };

					// Left (Rotates neck left between 0 and -degreeLimit)

					// 1. If cursor is in the left half of screen
					if (x <= w.x / 2) {
						// 2. Get the difference between middle of screen and cursor position
						xdiff = w.x / 2 - x;
						// 3. Find the percentage of that difference (percentage toward edge of screen)
						xPercentage = (xdiff / (w.x / 2)) * 100;
						// 4. Convert that to a percentage of the maximum rotation we allow for the neck
						dx = ((degreeLimit * xPercentage) / 100) * -1;
					}
					// Right (Rotates neck right between 0 and degreeLimit)
					if (x >= w.x / 2) {
						xdiff = x - w.x / 2;
						xPercentage = (xdiff / (w.x / 2)) * 100;
						dx = (degreeLimit * xPercentage) / 100;
					}
					// Up (Rotates neck up between 0 and -degreeLimit)
					if (y <= w.y / 2) {
						ydiff = w.y / 2 - y;
						yPercentage = (ydiff / (w.y / 2)) * 100;
						// Note that I cut degreeLimit in half when she looks up
						dy = (((degreeLimit * 0.5) * yPercentage) / 100) * -1;
					}
					// Down (Rotates neck down between 0 and degreeLimit)
					if (y >= w.y / 2) {
						ydiff = y - w.y / 2;
						yPercentage = (ydiff / (w.y / 2)) * 100;
						dy = (degreeLimit * yPercentage) / 100;
					}
					return { x: dx, y: dy };

				}

			}

		})(); //endpoint
	</script>
</body>

</html>
